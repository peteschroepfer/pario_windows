/*++
Copyright (c) 2015 Dynamic Engineering All rights reserved.
   150 DuBois, Suite C
   Santa Cruz, CA 95060
   831-457-8891
   engineering@dyneng.com
   http://www.dyneng.com

Module Name:
   PmcParIo.c

Abstract:
   This is a WDF driver for the PmcParIo adapter.
   It illustrates how to use the WDF DmaObject to perform
   Scatter/Gather DMA operations.

Environment:
   Kernel mode
--*/

#include "Precomp.h"
//
// The trace message header (.tmh) file must be included in a source file
// before any WPP macro calls and after defining a WPP_CONTROL_GUIDS
// macro (defined in trace.h). During the compilation, WPP scans the source
// files for DoTraceMessage() calls and builds a .tmh file which stores a
// unique data GUID for each message, the text resource string for each
// message, and the data types of the variables passed in for each message.
// This file is automatically generated by the WPP preprocessor.
//
#include "device.tmh"


#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, PmcParIoEvtDeviceAdd)
#pragma alloc_text (PAGE, PmcParIoEvtDevicePrepareHardware)
#pragma alloc_text (PAGE, PmcParIoEvtDeviceReleaseHardware)
#pragma alloc_text (PAGE, PmcParIoEvtDeviceD0Exit)
#pragma alloc_text (PAGE, PmcParIoEvtDriverContextCleanup)
#pragma alloc_text (PAGE, PmcParIoSetIdleAndWakeSettings)
#endif

/*++
DriverEntry
Routine Description:
   Driver initialization entry point.
   This entry point is called directly by the I/O system.
Arguments:
   DriverObject - pointer to the driver object
   RegistryPath - pointer to a unicode string representing the path,
                  to driver-specific key in the registry.
Return Value:
   NTSTATUS     - if the status value is not STATUS_SUCCESS,
                  the driver will get unloaded immediately.
--*/
NTSTATUS DriverEntry(__in PDRIVER_OBJECT  DriverObject,
    __in PUNICODE_STRING RegistryPath)
{
    NTSTATUS              status = STATUS_SUCCESS;
    WDF_DRIVER_CONFIG     config;
    WDF_OBJECT_ATTRIBUTES attributes;

    // Initialize WDF WPP tracing.
    WPP_INIT_TRACING(DriverObject, RegistryPath);
    // TraceEvents function is mapped to DoTraceMessage provided by WPP by using
    //  a directive in the sources file.
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT,
        "PmcParIo - Driver Framework Edition.");
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT,
        "Built %s %s", __DATE__, __TIME__);
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT,
        "PmcParIo Registry Path: %wZ", RegistryPath);
    // Initialize the Driver Config structure.
    WDF_DRIVER_CONFIG_INIT(&config, PmcParIoEvtDeviceAdd);
    // Register a cleanup callback so that we can call WPP_CLEANUP
    //  when the framework driver object is deleted during driver unload.
    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
    attributes.EvtCleanupCallback = PmcParIoEvtDriverContextCleanup;
    status = WdfDriverCreate(DriverObject,
        RegistryPath,
        &attributes,
        &config,
        WDF_NO_HANDLE);

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_PNP,
            "WdfDriverCreate failed with status %!STATUS!", status);
        // Cleanup tracing here because DriverContextCleanup will not be called as
        //  we have failed to a create WDFDRIVER object.
        WPP_CLEANUP(DriverObject);
    }
    return status;
}// DriverEntry

/*++
PmcParIoEvtDeviceAdd
Routine Description:
   EvtDeviceAdd is called by the framework in response to an AddDevice
   call from the PnP manager. Here the driver should register all the
   PNP, power and Io callbacks, register interfaces and allocate other
   software resources required by the device. The driver can query
   any interfaces or get the config space information from the bus driver
   but cannot access hardware registers or initialize the device.
Arguments:
   Driver     - handle to a WDF Driver object.
   DeviceInit - pointer to the device initialization structure.
Return Value:
   NTSTATUS
--*/
NTSTATUS PmcParIoEvtDeviceAdd(__in    WDFDRIVER       Driver,
    __inout PWDFDEVICE_INIT DeviceInit)
{
    NTSTATUS                     status = STATUS_SUCCESS;
    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
    WDF_OBJECT_ATTRIBUTES        fdoAttributes;
    WDFDEVICE                    device;
    PDEVICE_EXTENSION            pDevExt = NULL;

    UNREFERENCED_PARAMETER(Driver);
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP, "--> PmcParIoEvtDeviceAdd");
    PAGED_CODE();

    WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoDirect);
    // Zero out the PnpPowerCallbacks structure.
   
    
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
    // Set Callbacks for any of the functions we are interested in.
    pnpPowerCallbacks.EvtDevicePrepareHardware = PmcParIoEvtDevicePrepareHardware;
    pnpPowerCallbacks.EvtDeviceReleaseHardware = PmcParIoEvtDeviceReleaseHardware;
    pnpPowerCallbacks.EvtDeviceD0Entry = PmcParIoEvtDeviceD0Entry;
    pnpPowerCallbacks.EvtDeviceD0Exit = PmcParIoEvtDeviceD0Exit;
    // Register the PnP Callbacks..
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);
    
    
    // Initialize Fdo Attributes.
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&fdoAttributes, DEVICE_EXTENSION);
    // Framework will serialize access to device-context by Io Events and
    //  DpcForIsr by using an internal device-lock.
    fdoAttributes.SynchronizationScope = WdfSynchronizationScopeDevice;
    // Create the device
    status = WdfDeviceCreate(&DeviceInit, &fdoAttributes, &device);
    if (!NT_SUCCESS(status)) {
        // Device Initialization failed.
        TraceEvents(TRACE_LEVEL_ERROR, DBG_PNP,
            "DeviceCreate failed %!STATUS!", status);
        return status;
    }
    // Get the DeviceExtension and initialize it. PmcParIoGetDeviceContext is inline
    //  function defined by WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro
    pDevExt = PmcParIoGetDeviceContext(device);
    pDevExt->Device = device;

    pDevExt->Pdo = WdfDeviceWdmGetPhysicalDevice(device);
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "     AddDevice PDO (0x%p) FDO (0x%p), pDevExt (0x%p)",
        pDevExt->Pdo,
        WdfDeviceWdmGetDeviceObject(device),
        pDevExt);

    // Tell the Framework that this device will need an interface
    status = WdfDeviceCreateDeviceInterface(device,
        (LPGUID)&GUID_PMC_PAR_IO_INTERFACE,
        NULL);
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_PNP,
            "<-- PmcParIoEvtDeviceAdd DeviceCreateDeviceInterface failed %!STATUS!",
            status);
        return status;
    }

    // we don't care if this fails because device will just stay in higher power state
    // Set the idle and wait-wake policy for this device.
    PmcParIoSetIdleAndWakeSettings(pDevExt);
    status = STATUS_SUCCESS;

    // Initalize the Device Extension.
    status = PmcParIoInitializeDeviceExtension(pDevExt);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "<-- PmcParIoEvtDeviceAdd %!STATUS!", status);
    return status;
}// PmcParIoEvtDeviceAdd

/*++
PmcParIoEvtDevicePrepareHardware
Routine Description:
   Performs whatever initialization is needed to setup the device, setting up
   a DMA channel or mapping any I/O port resources. This will only be called
   as a device starts or restarts, not every time the device moves into the D0
   state. Consequently, most hardware initialization belongs elsewhere.
Arguments:
   Device             -A handle to the WDFDEVICE
   Resources          -The raw PnP resources associated with the device.
                       Most of the time, these aren't useful for a PCI device.
   ResourcesTranslated-The translated PnP resources associated with the
                       device. This is what is important to a PCI device.
Return Value:
   NTSTATUS code      -Failure will result in the device stack being torn down
--*/
NTSTATUS PmcParIoEvtDevicePrepareHardware(__in WDFDEVICE    Device,
    __in WDFCMRESLIST Resources,
    __in WDFCMRESLIST ResourcesTranslated)
{
    NTSTATUS          status = STATUS_SUCCESS;
    PDEVICE_EXTENSION pDevExt;

    UNREFERENCED_PARAMETER(Resources);
    PAGED_CODE();
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "--> PmcParIoEvtDevicePrepareHardware");
    pDevExt = PmcParIoGetDeviceContext(Device);
    status = PmcParIoPrepareHardware(pDevExt, ResourcesTranslated);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "<-- PmcParIoEvtDevicePrepareHardware, status %!STATUS!", status);
    return status;
}// PmcParIoEvtDevicePrepareHardware

/*++
PmcParIoEvtDeviceReleaseHardware
Routine Description:
   Unmap the resources that were mapped in PmcParIoEvtDevicePrepareHardware.
   This will only be called when the device is stopped for resource rebalance,
   surprise-removed or query-removed.
Arguments:
   Device              - A handle to the WDFDEVICE
   ResourcesTranslated - The translated PnP resources associated with the
                         device. This is what is important to a PCI device.
Return Value:
   NTSTATUS code       -failure will result in the device stack being torn down
--*/
NTSTATUS PmcParIoEvtDeviceReleaseHardware(__in WDFDEVICE    Device,
    __in WDFCMRESLIST ResourcesTranslated)
{
    PDEVICE_EXTENSION pDevExt;
    NTSTATUS          status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ResourcesTranslated);
    PAGED_CODE();
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "--> PmcParIoEvtDeviceReleaseHardware");
    pDevExt = PmcParIoGetDeviceContext(Device);
    if (pDevExt->RegsBase) {
        MmUnmapIoSpace(pDevExt->RegsBase, pDevExt->RegsLength);
        pDevExt->RegsBase = NULL;
    }
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "<-- PmcParIoEvtDeviceReleaseHardware");
    return status;
}// PmcParIoEvtDeviceReleaseHardware

/*++
PmcParIoEvtDeviceD0Entry
Routine Description:
   This routine prepares the device for use.  It is called whenever the device
   enters the D0 state, which happens when the device is started, when it is
   restarted, and when it has been powered off.
      Note that interrupts will not be enabled at the time that this is called.
   They will be enabled after this callback completes.
      This function is not marked pageable because this function is in the
   device power up path. When a function is marked pagable and the code
   section is paged out, it will generate a page fault which could impact
   the fast resume behavior because the client driver will have to wait
   until the system drivers can service this page fault.
Arguments:
   Device        - The handle to the WDF device object
   PreviousState - The state the device was in before this callback was invoked
Return Value:
   NTSTATUS      - Success implies that the device can be used.  Failure will
                   result in the device stack being torn down.
--*/
NTSTATUS PmcParIoEvtDeviceD0Entry(__in WDFDEVICE              Device,
    __in WDF_POWER_DEVICE_STATE PreviousState)
{
    PDEVICE_EXTENSION pDevExt;

    UNREFERENCED_PARAMETER(PreviousState);
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP, "--> PmcParIoEvtDeviceD0Entry");
    pDevExt = PmcParIoGetDeviceContext(Device);
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP, "<-- PmcParIoEvtDeviceD0Entry");
    return PmcParIoInitializeHardware(pDevExt);
}// PmcParIoEvtDeviceD0Entry

/*++
PmcParIoEvtDeviceD0Exit
Routine Description:
   This routine undoes anything done in PmcParIoEvtDeviceD0Entry.  It is called
   whenever the device leaves the D0 state, which happens when the device
   is stopped, when it is removed, and when it is powered off.
   The device is still in D0 when this callback is invoked, which means that
   the driver can still touch hardware in this routine.
   Note that interrupts have already been disabled by the time that this
   callback is invoked.
Arguments:
   Device      - The handle to the WDF device object
   TargetState - The state the device will go to when this callback completes.
Return Value:
   NTSTATUS    - Success implies that the device can be used.
                 Failure will result in the device stack being torn down.
--*/
NTSTATUS PmcParIoEvtDeviceD0Exit(__in WDFDEVICE              Device,
    __in WDF_POWER_DEVICE_STATE TargetState)
{
    PDEVICE_EXTENSION pDevExt;

    PAGED_CODE();
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP, "--> PmcParIoEvtDeviceD0Exit");
    pDevExt = PmcParIoGetDeviceContext(Device);
    switch (TargetState) {
    case WdfPowerDeviceD1:
    case WdfPowerDeviceD2:
    case WdfPowerDeviceD3:
        // Fill in any code to save hardware state and put the device in a
        //  low-power state here.
        break;
    case WdfPowerDevicePrepareForHibernation:
        // Fill in any code to save hardware state here. Do not put in any code to
        // shut the device off. If this device cannot support being in the paging
        // path (or being a parent or grandparent of a paging path device) then
        // this whole case can be deleted.
        break;
    case WdfPowerDeviceD3Final:
    default:
        // Reset the hardware, as we're shutting down for the last time.
        PmcParIoShutdown(pDevExt);
    }
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP, "<-- PmcParIoEvtDeviceD0Exit");
    return STATUS_SUCCESS;
}// PmcParIoEvtDeviceD0Exit

/*++
PmcParIoEvtDriverContextCleanup
Routine Description:
   Free all the resources allocated in DriverEntry.
Arguments:
   Driver - handle to a WDF Driver object.
Return Value:
   VOID.
--*/
VOID PmcParIoEvtDriverContextCleanup(WDFDRIVER Driver)
{
    PAGED_CODE();
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT,
        "--> PmcParIoEvtDriverContextCleanup: enter");
    WPP_CLEANUP(WdfDriverWdmGetDriverObject(Driver));
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT,
        "<-- PmcParIoEvtDriverContextCleanup: exit");
}// PmcParIoEvtDriverContextCleanup

/*++
PmcParIoSetIdleAndWakeSettings
Routine Description:
   Called by EvtDeviceAdd to set the idle and wait-wake policy.
   Registering this policy causes Power Management Tab to show up in the
   device manager. By default these options are enabled and the user is
   provided control to change the settings.
Arguments:
   FdoData  - Pointer to the Device Extension
Return Value:
   NTSTATUS - Failure status is returned if the device is not capable of
   suspending or wait-waking the machine by an external event. Framework checks
   the capability information reported by the bus driver to decide whether the
   device is capable of waking the machine.
--*/
NTSTATUS PmcParIoSetIdleAndWakeSettings(__in PDEVICE_EXTENSION FdoData)
{
    WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS idleSettings;
    WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS wakeSettings;
    NTSTATUS                              status = STATUS_SUCCESS;

    PAGED_CODE();
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "--> PmcParIoSetIdleAndWakeSettings");
    // Init the idle policy structure.

    WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_INIT(
        &idleSettings,
        IdleCanWakeFromS0
    );
    idleSettings.IdleTimeout = 10000;

    status = WdfDeviceAssignS0IdleSettings(
        FdoData->Device,
        &idleSettings
    );
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_PNP,
            "WdfDeviceAssignS0IdleSettings failed %!STATUS!", status);
    }
    // Init wait-wake policy structure.
    WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_INIT(&wakeSettings);
    status = WdfDeviceAssignSxWakeSettings(FdoData->Device, &wakeSettings);
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_PNP,
            "DeviceAssignSxWakeSettings failed %!STATUS!", status);
    }
    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP,
        "<-- PmcParIoSetIdleAndWakeSettings");
    return STATUS_SUCCESS;
}// PmcParIoSetIdleAndWakeSettings



